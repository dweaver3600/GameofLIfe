<!doctype html>
<html>
<head>
    <title>This is an HTML canvas</title>
    <link rel="stylesheet" href="../assets/styles.css">
    <script type="text/javascript" src="../assets/draw-stuff - END RESULT.js"></script>
</head>
<body>
    <h1>Conway's Game of Life</h1>
    <h4>Time-stamp: <2019-04-21 20:11:03 DAW></h4>
    <p id="parray"></p>

    <canvas id="grid" width="410" height="240"></canvas>
    <button id="all" onclick="end_result_button(context)">END RESULT</button>
    <button id="step" onclick="draw_rect_step(context)">Step Through</button>

    <script>
        // after "Introducing JavaScript Game Development" by Stuart.

        // =====================================================  draw_title ====
        // Draw filled rect.
        function draw_title(context) {
            context.save();
            context.fillStyle = 'lightgrey';
            context.font = "30px Arial";
            context.fillText("Grid", 150, 140);

            context.restore();
        }
        // =====================================================  Main ====
        var canvas = document.getElementById("grid");
        var context = canvas.getContext("2d");

        //draw_rect(context); // a gray rectangle

        // Draw a grid
        //draw_grid( context, 10, 50, 'white', 'yellow' );

        //draw_title( context );  The word "Grid"

        //context.fillStyle = "red";

        //context.putImageData(imgData, 0, 0);
    </script>

    <script>
        // -----------------------------------------------------
        //
        // This scrip contains all the data for the Game of Life
        //
        // -----------------------------------------------------


        // *~~~~~~~~~~~*
        // VARIABLES
        // *~~~~~~~~~~~*

        var sx = 1;            // script x variable - used to shift head by grid column (every column is 10 pixels wide)
        var psx = sx;          // temporary previous script x variable

        var y_offset = (canvas.height - 200);  // the offset for y
        // pushes y down the canvas
        // MANIPULATE THIS IN THE NUMBER OF CELLS TO BE OFFSET

        var sy = 1 + y_offset; // script y variable - used to shift head by grid row (every row is 10 pixels wide)

        var psy = sy;          // temporary previous sript y variable

        var cell = 0;          // current cell variable
        var cstep = 0;         // current step variable                                ~ unused
        var tstep = 0;         // current Turing machine step variable                 ~ unused

        var hidden_color = "white"; // the color hidden by the head symbol (red marker). used to remember what the color of the current cell is                            ~ unused

        var cell_color = [];   // an array of all the colors on the grid

        var new_cell_color = [];

        var color_set = [];    // an array (of max length 3) that holds the last three colors passed over by the TM head. used to evaluate the current pattern             ~ unused
        var pattern_fill = "white";    // the variable where the pattern evaluation is stored as a color. ex: b, w, w -> patternfill = white ~ unused

        var previous_color;    // the color of the cell before the color of the current cell
        var current_color;     // the color of the current cell
        var next_color;        // the color of the cell after the color of the current cell

        var new_color = true;  // ~ unused
        var set_up = true;     // a boolean that stores whether or not the set up function was completed and run at once

        var left_edge = false;     // a boolean that stores whether or not the leftmost cell has been evaluated
        var right_edge = false;    // a boolean that stores whether or not the rightmost cell has been evaluated

        var neighbors_alive = 0;   // a variable that keeps track of how many alive neighbors the current cell has

        // the following function is the main function that is run when
        //
        //

        function draw_rect_step(ctx, stroke, fill) {

            if (set_up == true) { setup_step(ctx); set_up = false; return; }

            // ~~~~~pseudocode~~~~~
            //
            // evaluate the neighbors
            // color current cell the color of pattern fill
            // move head over
            //
            //~~~~~~~~~~~~~~~~~~~~~

            if (right_edge == true) {
                ctx.fillStyle = cell_color[cell - 1];
                ctx.fillRect(401, psy - 10, 8, 8);
                right_edge = false;
            }

            ctx.fillStyle = cell_color[cell - 1];
            ctx.fillRect(psx - 10, psy, 8, 8);

            if (sx + 10 > 401) { // if the cell is  last in the column
                //alert("right edge");

                if (sy == 191 + y_offset) {

                    evaluate_neighbors(ctx)

                    ctx.fillStyle = cell_color[cell - 1];
                    ctx.fillRect(psx - 10, psy, 8, 8);

                    sx = 1;
                    sy = 1 + y_offset;
                    cell = 0;

                    color_all(ctx)

                    //for (var x = 0; x < cell_color.length - 1; x++) { alert(cell_color[x]) }

                    ctx.fillStyle = "red";
                    ctx.fillRect(psx, psy, 8, 8)

                    psx = sx;
                    psy = sy;

                    right_edge = true;
                    left_edge = false;

                    return;
                }

                //evaluate right edge
                evaluate_neighbors(ctx);

                ctx.fillStyle = cell_color[cell - 1];
                ctx.fillRect(411, psy, 8, 8);

                sx = 1;
                sy += 10;
                cell++;

                ctx.fillStyle = "red";
                ctx.fillRect(psx, psy, 8, 8)

                psx = sx;
                psy = sy;

                right_edge = true;
                left_edge = false;

                return;
            }

            else { /* not leftmost or rightmost edge */ }

            evaluate_neighbors(ctx);

            ctx.fillStyle = cell_color[cell - 1]; // color in the current cell
            ctx.fillRect(psx - 10, psy, 8, 8);

            sx += 10;

            ctx.fillStyle = "red"; //color in the current cell
            ctx.fillRect(psx, psy, 8, 8);

            psx = sx;
            psy = sy;

            cell++;

            ctx.restore();
        } // end draw_rect_step


        // -----------------------------------------------------
        //
        // USE THE SETUP_STEP FUNCTION TO INITIATE THE SEED (GENERATION 0)
        //
        // -----------------------------------------------------
        function setup_step(ctx, stroke, fill) {
            //document.getElementById('all').style.visibility = 'hidden';

            stroke = stroke || 'lightgrey';
            fill = fill || 'white';
            ctx.save();
            ctx.strokeStyle = stroke;
            ctx.fillStyle = fill;
            ctx.lineWidth = 5;

            ctx.fill();

            ctx.fillStyle = 'white';

            // initial setup
            //      Store the value of every pixel as white
            for (var y = 1 + y_offset; y < 201 + y_offset; y += 10) {
                for (var x = 1; x < 411; x += 10) {
                    ctx.fillRect(x, y, 8, 8);
                    cell_color.push("white"); // 820 cell_color elements
                }
            }

            // create 3x3
            for (var y = 1; y < 31; y += 10) {
                for (var x = 1 + 19 * 10; x < 1 + 19 * 10 + 30; x += 10) {
                    ctx.fillRect(x, y, 8, 8);
                }
            }

            ctx.fillRect(220, 0, 190, 40)
            ctx.fillRect(0, 0, 190, 40) // Left
            ctx.fillRect(0, 30, 410, 10) // separator

            ctx.fillStyle = "red";

            ctx.fillRect(1 + 200, 1 + 10, 8, 8); // The middle of 3v3 grid

            evaluate_neighbors(ctx)

            ctx.fillStyle = "black";

            zeroth = 1;
            for (var x = 0; x < 20; x++) {
                // fillRect(xcoord, ycoord, xlength, ylength)
                if (x % 6 == 0) { continue; }
                ctx.fillRect(zeroth * 10 + 1, 1 + y_offset + 10 * x, 8, 8); // The 20th cell
                cell_color[zeroth + 41 * x] = ("black");
            }

            zeroth = 40;
            for (var x = 0; x < 20; x++) {
                // fillRect(xcoord, ycoord, xlength, ylength)
                ctx.fillRect(zeroth * 10 + 1, 1 + y_offset + 10 * x, 8, 8); // The 20th cell
                cell_color[zeroth + 41 * x] = ("black");
            }

            zeroth = 11;
            for (var x = 0; x < 20; x++) {
                if ((x + 2) % 4 == 0) { continue; }
                // fillRect(xcoord, ycoord, xlength, ylength)
                ctx.fillRect(zeroth * 10 + 1, 1 + y_offset + 10 * x, 8, 8); // The 20th cell
                cell_color[zeroth + 41 * x] = ("black");
            }

            zeroth = 26;
            for (var x = 0; x < 20; x++) {
                if ((x + 4) % 6 == 0) { continue; }
                // fillRect(xcoord, ycoord, xlength, ylength)
                ctx.fillRect(zeroth * 10 + 1, 1 + y_offset + 10 * x, 8, 8); // The 20th cell
                cell_color[zeroth + 41 * x] = ("black");
            }

        } // end setup_step function;


        // The following function evaluates the 8 neighbors of the current cell
        //
        // + - - - + - - - + - - - +
        // |nbor UL|nbor U |nbor UR|
        // |   -42 |   -41 |  -40  |
        // + - - - + - - - + - - - +
        // |nbor L |current|nbor R |
        // |   -1  |  cell |   +1  |
        // + - - - + - - - + - - - +
        // |nbor DL|nbor D |nbor DR|
        // |   +40 |   +41 |   +42 |
        // + - - - + - - - + - - - +
        //
        //-----------------------------------------------------------------------
        function evaluate_neighbors(ctx, stroke, fill) {
            neighbors_alive = 0;

            // IMPORTANT ~ consider whether the upper neighbors are on the grid

            // IMPORTANT ~ consider whether the left_most neighbors are on the grid

            // IMPORTANT ~ consider whether the right_most neighbors are on the grid

            // IMPORTANT ~ consider whether the lower neighbors are on the grid

            // refresh 3x3
            ctx.fillStyle = "white"
            for (var y = 1; y < 31; y += 10) {
                for (var x = 1 + 19 * 10; x < 1 + 19 * 10 + 30; x += 10) {
                    ctx.fillRect(x, y, 8, 8);
                }
            }

            ctx.fillStyle = "red"
            ctx.fillRect(1 + 200, 1 + 10, 8, 8); // The middle of 3v3 grid

            ctx.fillStyle = "black";

            // neighbor U
            if (cell - 41 < 0 ||
                sy - 10 < 1 + y_offset) { }
            else if (cell_color[cell - 41] == "black") { neighbors_alive++; ctx.fillRect(1 + 200, 1, 8, 8); }

            // neighbor UL
            if (cell - 42 < 0 ||
                (sy - 10) < 1 + y_offset ||
                (sx - 10) < 1) { }
            else if (cell_color[cell - 42] == "black") { neighbors_alive++; ctx.fillRect(1 + 190, 1, 8, 8); }

            // neighbor UR
            if (cell - 40 < 0 ||
                (sy - 10) < 1 + y_offset ||
                (sx + 10) > 410) { }
            else if (cell_color[cell - 40] == "black") { neighbors_alive++; ctx.fillRect(1 + 210, 1, 8, 8); }

            // neighbor R
            if (cell + 1 > 820 ||
                (sx + 10) > 410) { }
            else if (cell_color[cell + 1] == "black") { neighbors_alive++; ctx.fillRect(1 + 210, 11, 8, 8); }

            // neighbor L
            if (cell - 1 < 0 ||
                (sx - 10) < 1) { }
            else if (cell_color[cell - 1] == "black") { neighbors_alive++; ctx.fillRect(1 + 190, 11, 8, 8); }

            // neighbor D
            if (cell + 41 > 820 ||
                (sy + 10) > 200 + y_offset) { }
            else if (cell_color[cell + 41] == "black") { neighbors_alive++; ctx.fillRect(1 + 200, 21, 8, 8); }

            // neighbor DL
            if (cell + 40 > 820 ||
                (sy + 10) > 200 + y_offset ||
                (sx - 10) < 1) { }
            else if (cell_color[cell + 40] == "black") { neighbors_alive++; ctx.fillRect(1 + 190, 21, 8, 8); }

            // neighbor DR
            if (cell + 42 > 820 ||
                (sy + 10) > 200 + y_offset ||
                (sx + 10) > 410) { }
            else if (cell_color[cell + 42] == "black") { neighbors_alive++; ctx.fillRect(1 + 210, 21, 8, 8); }

            //if (neighbors_alive > 0) alert(cell + " " + neighbors_alive)

            color(ctx)
        } // end evaluate_neighbors function


        // The color function evaulates what the color of the cell will be based on how many
        // alive neighbors there are
        function color(ctx, stroke, fill) {

            // kill cell by underpopulation  (alive < 2) or overpopulation (alive > 3)
            if (neighbors_alive < 2 || neighbors_alive > 3) { new_cell_color[cell] = "white"; }

            // if the cell is alive and it has two or three alive neighbors, keep alive
            else if ((neighbors_alive == 2 || neighbors_alive == 3) && cell_color[cell] == "black") { new_cell_color[cell] = "black" }

            // birth a cell if the current cell is dead and the number of neighbors alive is 3
            else if (neighbors_alive == 3 && cell_color[cell] == "white") { new_cell_color[cell] = "black"; }

            else { new_cell_color[cell] = cell_color[cell] }

            //if (new_cell_color[cell] == "black") alert(cell + " is black")
        }

        function color_all(ctx, stroke, fill) {
            var temp_cell = 0;

            //alert("color_all function")
            for (var y = 1 + y_offset; y < 200 + y_offset; y += 10) {
                for (var x = 1; x < 410; x += 10) {
                    //if (new_cell_color[temp_cell] == "black") { alert("new_cell_color " + temp_cell + " black") }
                    ctx.fillStyle = new_cell_color[temp_cell]
                    ctx.fillRect(x, y, 8, 8);
                    temp_cell++;
                }
            }

            cell_color = [];
            cell_color = new_cell_color.slice();

            new_cell_color = [];
        }

        function end_result_button(ctx, stroke, fill) {
            while (cell < 41 * 20) {

                if (set_up == true) { setup_step(ctx); set_up = false; return; }

                if (sx + 10 > 401) { // if the cell is  last in the column

                    // if the head is at the last column of the last row
                    if (sy == 191 + y_offset) {
                        evaluate_neighbors(ctx)

                        ctx.fillStyle = cell_color[cell];
                        ctx.fillRect(psx, psy, 8, 8);

                        sx = 1;
                        sy = 1 + y_offset;
                        cell = 0;

                        color_all(ctx)

                        psx = sx;
                        psy = sy;

                        right_edge = false;
                        left_edge = false;

                        return;
                    }

                    //evaluate right edge
                    evaluate_neighbors(ctx);

                    ctx.fillStyle = cell_color[cell];
                    ctx.fillRect(psx, psy, 8, 8);

                    sx = 1;
                    sy += 10;
                    cell++;

                    psx = sx;
                    psy = sy;

                    right_edge = false;
                    left_edge = false;
                }

                else { /* not leftmost or rightmost edge */ }

                evaluate_neighbors(ctx);

                ctx.fillStyle = cell_color[cell]; // color in the current cell
                ctx.fillRect(sx, sy, 8, 8);

                sx += 10;

                psx = sx;
                psy = sy;

                cell++;

                ctx.restore();
            }
        } // end end_result_button function

        function set_up_Gosper(ctx, fill, stroke) {

        }

            // -----------------------------------------------------
            //
            // End Game of Life Script
            //
            // -----------------------------------------------------
    </script>
</body>

</html>
